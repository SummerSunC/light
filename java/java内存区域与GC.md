# java 内存区域与GC机制

### 写在前面
> 默认虚拟机：HotSpot

## java内存区域
### 内存区域
- 程序计数器
- 栈
    - 虚拟机栈
    - 本地方法栈
- 堆
    - 普通堆区
    - 方法区（版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等，基本不会进行垃圾回收，也不是绝对）
        - 运行时常量池（存储编译时即时生成的字面常量、符号引用、翻译出来的直接引用）

    
### java对象访问方式

``` java
Object obj = new Object()
```
这里访问的方式为：
- Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据
- new Object()作为实例对象数据存储在堆中
- 堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中

### java内存分配方式
这里的的内存分配实际上是在堆上的内存分配。java采取的内存分配机智是：**分代分配，分代回收**。

- 年轻代（Young Generation）:
对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。

- 年老代（Old Generation）:
对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。

- 永久代（Permanent Generation，在HotSpot虚拟机中是方法区）:
基本不进行垃圾回收

## GC
### 年轻代
在年轻代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中，然后清理掉Eden和刚才的Survivor。
### 老年代
老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续
### 永久代
　永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：
- 类的所有实例都已经被回收
- 加载类的ClassLoader已经被回收
- 类对象的Class对象没有被引用（即没有通过反射引用该类的地方）